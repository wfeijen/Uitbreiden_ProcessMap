
#' @title Process Map Styled
#'
#'
#' @description A function for creating a process map of an event log.
#' @param eventlog The event log object for which to create a process map
#' @param edge_with_metric Defines the type of metric shown by the with of the edges, which can be created with the functions frequency and performance. The first type focusses on the frequency aspect of a process, while the second one focussed on processing time.
#' @param render Whether the map should be rendered immediately (default), or rather an object of type dgr_graph should be returned.
#' @param testx check of ik mijn eigen package zie
#'
#'
#' @examples
#' \dontrun{
#' library(eventdataR)
#' data(patients)
#' process_map(patients)
#' }
#' @export process_map_styled


# We aim at maximum flexibility by:
# 1 visualizing multiple metrics by:
#	a- edge with
#	b- edge color black to red
#   c- edge color black to blue
# 2 simplifieng the graph by leaving edges out based on metric. This can be done in two ways:
#	1- as a percentage of all edges (I.E. 0.5 shows half of the edges)
#	2- as an absolute number>1 (I.E. 10 shows at most 10 edges)

process_map_styled <- function(eventlog
							   , metric_type = frequency("absolute")
							   , render = T) {
	act <- NULL
	aid <- NULL
	case <- NULL
	time <- NULL
	start_time <- NULL
	end_time <- NULL
	node_id <- NULL
	n.x <- NULL
	n.y <- NULL
	from_id <- NULL
	tooltip <- NULL
	label <- NULL
	next_act <- NULL
	to_id <- NULL
	duration <- NULL
	value <- NULL
	color_level <- NULL

	if(n_traces(eventlog) > 750) {
		message("You are about to draw a process map with a lot of traces.
				This might take a long time. Try to filter your event log. Are you sure you want to proceed?")
		answer <- readline("Y/N: ")

		if(answer != "Y")
			break()
	}

	eventlog %>%
		as.data.frame() %>%
		droplevels %>%
		select(act = !!activity_id_(eventlog),
			   aid = !!activity_instance_id_(eventlog),
			   case = !!case_id_(eventlog),
			   time = !!timestamp_(eventlog)) %>%
		group_by(act, aid, case) %>%
		summarize(start_time = min(time),
				  end_time = max(time)) -> base_log


	base_log %>%
		group_by(case) %>%
		arrange(start_time) %>%
		slice(c(1,n())) %>%
		mutate(act = c("Start","End")) %>%
		mutate(start_time = recode(act, "End" = end_time, .default = start_time)) %>%
		mutate(end_time = recode(act, "Start" = start_time, .default = end_time)) -> end_points


	base_log  %>%
		bind_rows(end_points) -> base_log

	base_log %>%
		ungroup() %>%
		count(act) %>%
		mutate(node_id = 1:n()) -> base_nodes

	suppressWarnings(base_log %>%
		ungroup() %>%
		mutate(act = ordered(act, levels = c("Start", as.character(activity_labels(eventlog)), "End"))) %>%
		group_by(case) %>%
		arrange(start_time, act) %>%
		mutate(next_act = lead(act),
			   next_start_time = lead(start_time),
			   next_end_time = lead(end_time)) %>%
		full_join(base_nodes, by = c("act" = "act")) %>%
		rename(from_id = node_id) %>%
		full_join(base_nodes, by = c("next_act" = "act")) %>%
		rename(to_id = node_id) %>%
		select(-n.x, -n.y) -> base_precedence)


	if_end <- function(node, true, false) {
		ifelse(node %in% c("Start","End"), true, false)
	}
	if_start <- function(node, true, false) {
		ifelse(node %in% c("Start"), true, false)
	}





	nodes_collumn <- function(precedence, metric_type) {

		precedence %>%
			group_by(act, from_id) %>%
			summarize(n = as.double(n())) %>%
			ungroup() %>%
			mutate(label = case_when(metric_type == "relative" ~ n/sum(n),
									 metric_type == "absolute" ~ n)) %>%
			mutate(color_level = label,
				   shape = if_end(act,"circle","rectangle"),
				   fontcolor = if_end(act, if_start(act, "chartreuse4","brown4"),  ifelse(label <= quantile(label, 0.4), "black","white")),
				   color = if_end(act, if_start(act, "chartreuse4","brown4"),"grey"),
				   tooltip = paste0(act, "\n (", round(label, 2), ")"),
				   label = if_end(act, act, tooltip)) %>%
			na.omit()
	}

	nodes_performance <- function(precedence, metric_type,redness_metric,blueness_metric) {

		precedence %>%
			mutate(duration = as.double(end_time-start_time, units = attr(metric_type, "units"))) %>%
			group_by(act, from_id) %>%
			summarize(label = metric_type(duration)) %>%
			na.omit() %>%
			ungroup() %>%
			mutate(color_level = label,
				   shape = if_end(act,"circle","rectangle"),
				   fontcolor = if_end(act, if_start(act, "chartreuse4","brown4"),  ifelse(label <= quantile(label, 0.65), "black","white")),
				   color = if_end(act, if_start(act, "chartreuse4","brown4"),"grey"),
				   tooltip = paste0(act, "\n (", round(label, 2), " ",attr(metric_type, "units"),")"),
				   label = if_end(act, act, tooltip))
	}


	nodes_frequency <- function(precedence, metric_type) {

		precedence %>%
			group_by(act, from_id) %>%
			summarize(n = as.double(n())) %>%
			ungroup() %>%
			mutate(label = case_when(metric_type == "relative" ~ n/sum(n),
									 metric_type == "absolute" ~ n)) %>%
			mutate(color_level = label,
				   shape = if_end(act,"circle","rectangle"),
				   fontcolor = if_end(act, if_start(act, "chartreuse4","brown4"),  ifelse(label <= quantile(label, 0.4), "black","white")),
				   color = if_end(act, if_start(act, "chartreuse4","brown4"),"grey"),
				   tooltip = paste0(act, "\n (", round(label, 2), ")"),
				   label = if_end(act, act, tooltip)) %>%
			na.omit()
	}


	edges_performance <- function(precedence, metric_type) {

		flow_time <- attr(metric_type, "flow_time")
		precedence %>% ungroup() ->i1
		i1 %>% mutate(time = case_when(flow_time == "inter_start_time" ~ as.double(next_start_time - start_time, units = attr(metric_type, "units")),flow_time == "idle_time" ~ as.double(next_start_time - end_time, units = attr(metric_type, "units")))) ->i2
		i2 %>% group_by(act, next_act, from_id, to_id) ->i3
		i3 %>% summarize(value = metric_type(time), label = paste0(round(metric_type(time),2), " ", attr(metric_type, "units"))) ->i4
		i4 %>%	na.omit() ->i5
		i5 %>%	ungroup() ->i6
		i6 %>%	mutate(penwidth = rescale(value, to = c(1,5))) ->i7
		i7 %>%	mutate(label = if_end(act, "", if_end(next_act, "", label))) ->i
		return(i)
	}

	edges_frequency <- function(precedence, metric_type) {
		precedence %>%ungroup()->i1
			i1 %>% group_by(act, from_id, next_act, to_id) ->i2
			i2 %>% summarize(n = as.double(n()),n2 = as.double(n())) ->i3
			i3 %>% na.omit() %>% group_by(act, from_id) ->i4
			i4 %>% mutate(label = case_when(metric_type == "relative" ~ round(100*n/sum(n),2),
									 metric_type == "absolute" ~ n)) ->i5
			i5 %>%	ungroup() ->i6
			i6 %>%	arrange(act, from_id, next_act, to_id) ->i7
			i7 %>%	mutate(penwidth = rescale(label, to = c(1,5)))->i
		return(i)

	}

	edges_frequency_metric <- function(precedence, metric_type) {
		precedence %>%
			ungroup() %>%
			group_by(act, from_id, next_act, to_id) %>%
			summarize(n = as.double(n()),n2 = as.double(n())) %>%
			na.omit() %>%
			group_by(act, from_id) %>%
			mutate(label = case_when(metric_type == "relative" ~ round(100*n/sum(n),2),
									 metric_type == "absolute" ~ n)) %>%
			ungroup() %>%
			arrange(act, from_id, next_act, to_id)$label
	}

	edges_metric <- function(precedence, edge_metric_type)#Only one metric and identifing attributes ordered
	{
		if (edge_metric_type=="none") return('error')
		perspective <- attr(edge_metric_type, "perspective")
		if(perspective == "frequency") {return(edges_frequency(precedence, edge_metric_type))}
		else if(perspective == "performance") return (edges_performance(precedence, edge_metric_type))
	}

	perspective <- function(metric_type){attr(metric_type, "perspective")}


	if(perspective(metric_type) == "frequency") {
		nodes_frequency(base_precedence, metric_type) -> nodes
	} else if(perspective(metric_type) == "performance")
		nodes_performance(base_precedence, metric_type) -> nodes


	if(perspective(metric_type) == "frequency") {
		edges_frequency(base_precedence, metric_type) -> edges
	} else if(perspective(metric_type) == "performance")
		edges_performance(base_precedence, metric_type) -> edges



	nodes %>%
		mutate(color_level = rescale(color_level)) %>%
		mutate(color_level = if_end(act, Inf, color_level)) -> nodes


	create_node_df(n = nrow(nodes),
				   label = nodes$label,
				   shape = nodes$shape,
				   color_level = nodes$color_level,
				   style = "rounded,filled",
				   fontcolor = nodes$fontcolor,
				   color = nodes$color,
				   tooltip = nodes$tooltip,
				   penwidth = 1.5,
				   fontname = "Arial") -> nodes_df

	min_level <- min(nodes_df$color_level)
	max_level <- max(nodes_df$color_level[nodes_df$color_level < Inf])

	#create_edge_df(from = edges$from_id,
	#			   to = edges$to_id,
	#			   label = #case_when( metric_type,redness_metric,blueness_metric
	#			   				   edges$label
	#			   					#)
	#,
	#			   penwidth = edges$penwidth,
	#			   color = ifelse(perspective(metric_type) == "performance", "red4", rgb(0, 1, 1, 0.5)),
	#			   fontname = "Arial",
	#				n = edges$label,
	#				xx = edges$n) -> edges_df
	
	create_edge_df(from = edges$from_id,
	               to = edges$to_id,
	               label = edges$label,
	               penwidth = edges$penwidth,
	               color = ifelse(perspective == "performance", "red4", "dodgerblue4"),
	               fontname = "Arial") -> edges_df


	create_graph(nodes_df, edges_df) %>%
		set_global_graph_attrs(attr = "rankdir", value = "LR",attr_type = "graph") %>%
		colorize_node_attrs(node_attr_from = "color_level",
							node_attr_to = "fillcolor",
							palette = ifelse(perspective(metric_type) == "performance", "Reds", "PuBu"),
							default_color = "white",
							cut_points = seq(min_level-0.1, max_level+.1, length.out = 9)) -> graph


	if(render == T) {
		graph %>% render_graph() %>% return()
	} else
		graph %>% return()

}
